---
title: Type Manipulation
description: 
published: true
tags: typescript
updatedAt: 2021-06-12
---

# Generics

[Generics | Official document](https://www.typescriptlang.org/docs/handbook/2/generics.html)

型をパラメータとして扱う事のできる仕組み。
例えば下記のように、オブジェクトの一部を異なる型に変えて再利用する事ができる。

```ts
type Item<T> = {
    id: T;
    name: string;
    price: number;
}

const books: Item<string>[] = [
    { id: "1111111111000", name: "ザリガニ図鑑", price: 1200 },
    { id: "1111111111001", name: "改訂版国語辞典", price: 2500 },
];

const foods: Item<number>[] = [
    { id: 1111, name: "長野産ブロッコリー", price: 180 },
    { id: 1112, name: "ピーマン10個入", price: 300 },
];
```

型指定のプレースホルダには `T` が使われる事が多いが、特に制約はないため自由なテキストを指定する事ができる。

```ts
type Item<T> = {
  id: T;
}

type Fetch<Response>: (id: number) => Response;
```

TypeScript の推論が効く範囲では、ジェネリクスの型指定は省略する事ができる。

```ts
function add<T>(list: T[], item: T): T[] {
    return list.concat(item);
}

add([1, 2], 3);
// > [1, 2, 3]

add(["a", "b"], "c");
// > ["a", "b", "c"]

add([1, 2], "a");
// > @error Argument of type 'string' is not assignable to parameter of type 'number'.
// 推論により number とみなされるため、string の "a" は指定できない
```

# Union Types

型の OR 条件を表現する事ができる。

```ts
type Pizza = {
  name: string;
  size: "S" | "M" | "L";
  count: number;
}

type SideMenu = {
  name: string;
  count: number;
};

const orders: (Pizza | SideMenu)[] = [
  { name: "チーズてんこ盛りピザ", size: "L", count: 1 },
  { name: "フライドオニオン", count: 1 },
];
```

Union Types により選択肢が限られるため、誤った値の代入を避ける事ができるようになる。

```ts
type pizza: Pizza = {
  name: "特大ピザ",
  size: "XL", // @error Type '"XL"' is not assignable to type 'Size'.
  count: 1,
};

const orders: (Pizza | SideMenu)[] = [
  { name: "クリスピータイプ生地" },
  // @error Type '{ name: string; }' is not assignable to type 'Pizza | SideMenu'.
];
```

# Mapped Types

オブジェクトのプロパティを走査した型指定ができる。

```ts
type HttpRequest = {
  header: {
    [key: string]: string;
  },
  body: string;
};

const response: HttpRequest = {
  header: {
    "Authorization": "secret",
  },
  body: "abc",
};
```

# Indexed Access Types

インデックスによる型の取り出し。

```ts
type Actions = {
  fetch: () => Promise<string>;
  post: () => Promise<void>;
};

type Fetch = Actions["fetch"];
// > () => Promise<void>

type Post = Actions["post"];
// > () => Promise<void>

type Put = Actions["put"];
// @error Property 'put' does not exist on type 'Actions'.
// 存在しないインデックスはエラーになる
```

# Conditional Types

型の条件分岐を作る事ができる。

```ts
type Message = {
    text: string | string[];
};

type Email = {
    title: string;
    text: string;
    to: string;
};

type Popup = {
    text: string[];
    dismiss: boolean;
};

type MessageText<T extends Message> = T["text"];

type EmailText = MessageText<Email>;
// > string

type PopupText = MessageText<Popup>;
// > string[]
```

# Utility Types

ビルトインの型変換ユーティリティ。

## Partial

オブジェクトのプロパティを一括でオプショナルに変換する。

```ts
type User = {
  id: number;
  firstName: string;
  lastName: string;
  nickname: string;
  age: number;
  address: string;
};

type Profile = Partial<User>;
// {
//   id?: number;
//   firstName?: string;
//   lastName?: string;
//   nickname?: string;
//   age?: number;
//   address?: string;
// };

const profile = {
    nickname: "a",
};
```

## Readonly

オブジェクトのプロパティを一括で読み取り専用に変換する。

```ts
type User = {
  firstName: string;
  lastName: string;
};

type PersistedUser = Readonly<User>;

const user: PersistedUser = {
  firstName: "a",
  lastName: "b",
};

user.firstName = "aaa";
// @error Cannot assign to 'firstName' because it is a read-only property.
```

## Record

Key/Type の組み合わせでオブジェクト型を生成する。

```ts
type PackageId = "core" | "sdk" | "utility"

type Package = {
  version: string;
  updatedAt: Date;
};

const packages: Record<PackageId, Package> = {
  core: { version: "v1.0", updatedAt: new Date("2021-01-19") },
  sdk: { version: "v0.31", updatedAt: new Date("2021-01-05") },
  utility: { version: "v5.2", updatedAt: new Date("2021-01-12") },
};
```

## ConstructorParameters

```ts
class User {
  constructor(
    private id: number,
    private name: string,
  ) {}
}

type UserArgs = ConstructorParameters<typeof User>;
// > [id: number, name: string]

function factory(args: FooArgs) {
    return new Foo(...args);
}
```

他にもいろいろある。
[Utility Types | 公式ドキュメント](https://www.typescriptlang.org/docs/handbook/utility-types.html)

# いろいろなタイプの組み合わせ

Generics やいろいろなタイプを組み合わせる事で、柔軟な型の抽出と、安全な宣言を導く事ができるようになる。

```ts
type PlainPassword = {
    username: string;
    password: string;
};

type OAuth = {
    target: "google" | "github";
    username: string;
};

type LoginInfo = Partial<PlainPassword & OAuth>;

function login(data: LoginInfo): boolean {
    if (data["password"]) {
       return (loginWithPlainPassword(data as PlainPassword));
    }

    return loginWithOAuth(data as OAuth);
}
```












```ts
type User = {
  name: string;
  age: number;
};

type Flags<T> = {
  [ K in keyof T ]: boolean;
};
```

```ts
type X = Flags<User>;
// {
//   name: boolean,
//   age: boolean,
// }
```


## オブジェクトのキーを Union Types で表現する

全てのキーを持つ事を表現する。

```ts
type Keys = "name" | "nickname";

type User = {
    [K in Keys]: string;
};

const user1: User = { 
    name: "foo",
    nickname: "bar",
};
```

いずれかのキーを持つ事を表現する。

```ts
type Keys = "name" | "nickname";

type User = {
    [K in Keys]?: string;
};

const user1: User = { 
    name: "foo",
};
```

## オブジェクトのプロパティ名を変換

```ts
type User = {
    name: string;
    age: number;
};

type Fetches<T> = {
    [ K in keyof T as `fetch${Capitalize<string & K>}`]: T[K];
};
```

```ts
type X = Fetches<User>;
// {
//     fetchName: string;
//     fetchAge: number;
// }
```

- `as` の部分は [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) という可変の文字列タイプを示す
- `Capitalize` の部分は [Intrinsic](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types) という文字列操作タイプを示す


# さまざまな抽出

## オブジェクトから任意の型のプロパティを抽出

```ts
type User = {
    name: string;
    age: number;
    address: string;
};

type Filter<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];
```

```ts
type X = Pick<User, Filter<User, string>>;
// {
//     name: string;
//     address: string;
// }
```

## オブジェクトから任意の型を持つキーを抽出

```ts
type User = {
    name: string;
    age: number;
    address: string;
};
type Filter<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];
```

```ts
type X = Filter<User, string>;
// "name" | "address"
```
