---
title: tsconfigのmoduleResolution
description: null
tags: typescript
updatedAt: 2023-04-19
published: true
---

## 参考

- [TypeScript で"moduleResolution": "Node"は使わないほうがいい](https://blog.s2n.tech/articles/dont-use-moduleresolution-node)
- [tsconfig.jsonのよく使いそうなオプションを理解する](https://zenn.dev/chida/articles/bdbcd59c90e2e1)
- [TypeScript 4\.7 と Native Node\.js ESM](https://quramy.medium.com/typescript-4-7-%E3%81%A8-native-node-js-esm-189753a19ba8)
- [TypeScriptのmoduleSuffixesについて考えて納得した](https://qiita.com/uhyo/items/22d851c3cbd2570864ce)

## Node.jsのモジュール解決

Node.jsにはcommonJSとESMの2通りのモジュール解決が存在する。
ESMはNode12からサポートされた。

### package.json `type` フィールド

Node>=12で使える。プロジェクト内のモジュール解決方法を指定する。
package.jsonはディレクトリごとに配置できるので、ディレクトリ単位での解決も可能。

- 指定なし:  CommonJS
- `type: "module"`: ESM
  - `.ts` `.js` をESMとして扱える
- `type: "commonjs"`: CommonJS

ファイル拡張子は以下のように扱われる。

拡張子 | モジュールタイプ
--- | ---
`.js` | `type:module`: ESM<br>`type:commonjs`: CJS
`.mjs` | ESM
`.cjs` | CJS

ESMとCJSを混在させる場合は以下の通り。

読み込み | Static import <br>`import {} from "foo"` | Dynamic import<br>`import(path).then` | `require()`
--- | --- | --- | ---
`ESM` から `ESM` を読み込む | OK | OK | NG
`CJS` から `CJS`を読み込む | NG | NG | OK
`ESM` から `CJS` を読み込む | OK | NG | NG
`CJS` から `ESM` を読み込む | NG | OK | NG

CommonJSや疑似ESM（バンドラがトランスパイル上CJSに変換する仕組み）で利用可能であった `__dirname` `process` はESMではアクセスできない。

package.jsonのtypeを無視してCJSやESMを出力したい場合は拡張子を以下のようにする。

- `.cts`: `.cjs` と `.d.cts` が出力される
- `.mts`: `.mjs` と `.d.mts` が出力される

### package.json `main` フィールド

Node.jsの古いバージョンのフォールバックとして利用される。Node.js v16から `exports` を指定する。

```ts
"main": "./lib/index.js"
```

### package.json `exports` フィールド

CommonJSとESMの両方のエントリポイントを同時に指定できる。main指定より優先される。

```ts
exports: {
  ".": {
    require: "foo.cjs",
    import: "bar.mjs"
  },
  subpath: {
    require: "subpath.cjs",
    import: "subpath.mjs"
  }
}
```

package.jsonが `type:"module"` で（ESM）、ファイル拡張子が `.js` で（自動判定）、ファイル内に `exports` がない時（commonJS）、モジュール読み込みに齟齬が発生し、このファイルはcommonJSだからESMとして読み込めないというエラーが出る。

## tsconfig.json `moduleResolution`

TS独自のモジュール解決の指定。

```ts
moduleResolution: "Classic" | "Node" | "Node10" | "Node16" | "NodeNext" | "Bundler"
```

- `Classic`
  - Classic TS 1.5 以前のモジュール解決。
- `Node` `Node10`
  - Node 12 以前のモジュール解決。type フィールドにかかわらず CommonJS が使用され main フィールドがエントリポイントになる。
- `Node16` `NodeNext`
  - type フィールドによって CommonJS / ES Modules が使用され exports フィールドがエントリポイントになる。
  - .js を読み込む場合は拡張子まで記述する必要がある。
  - top-level awaitが使える
- `Bundler`
  - type フィールドにかかわらず exports フィールドは require でなく import が使用される。なければ main がフォールバックになる。
  - .js を読み込む場合に拡張子を省略しても補完される。

TSには「トランスパイル後のコードに影響を与えない」という原則があるため、トランスパイル後のimportを書き換えない。コンパイルエラー（TSのモジュール解決）をしつつ、トランスパイル後のJSを気にする必要がある。実行環境がブラウザなら `.js` 一択で問題ないが、Node.jsの場合は `.js` `.cjs` `.mjs` とファイルが混在する。


トランスパイル後のコードのimportに拡張子を含めたい場合は、以下のように書く。TSのモジュール解決上は拡張子を無視していずれもfoo.tsを探しに行く。（foo.jsがあっても無視される）

```ts
import { foo } from "./foo.js";
import { foo } from "./foo.cjs";
import { foo } from "./foo.mjs";
```

トリプルスラッシュコメントの型参照はresolution-modeオプションで区別する。

```ts
/// <reference types="foo" resolution-mode="require" />
/// <reference types="bar" resolution-mode="import" />
```


## tsconfig.json `module` 

吐き出したJSがどのようにモジュール解決するかを指定する。

- `node16`
  - Node.js v16相当でESMを扱うモード
- `commonjs`
  - 既存のモード、たぶんこの名前

`node16` の場合、exportsフィールドの指定により出力ファイルをESM/CommonJSどちらでも読み込めるようにできる。

```ts
// package.json

exports: {
  ".": {
    require: {
      types: "./lib/index.d.cts",
      default: "./lib/index.cjs",
    },
    import: {
      types: "./lib/index.d.mts",
      default: "./lib/index.mjs",
    }
  }
},
types: "./types/index.d.ts", // Fall-back for older versions
main: "./lib/index.cjs", // Fall-back for older versions
```
