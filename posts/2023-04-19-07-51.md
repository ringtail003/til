---
title: tsconfigのmoduleResolution
description: null
tags: typescript
updatedAt: 2023-04-19
published: true
---

https://blog.s2n.tech/articles/dont-use-moduleresolution-node のメモ。

2023/04（TS v5.0）では "type" が見当たらないため、非推奨になったかも？
https://www.typescriptlang.org/tsconfig#types

## type

ES Modules は Node v12 以降、デフォルトで使用できる。

```ts
// ESModule
type: "module"
```

```ts
// CommonJS
type: "commonjs"
```

## main

CommonJS でのエントリポイント。

```ts
main: "foo.js"
```

## exports

ES Modules のエントリポイント。Node v12〜。

```ts
exports: {
  ".": {
    require: "foo.cjs",
    import: "bar.mjs"
  },
  subpath: {
    require: "subpath.cjs",
    import: "subpath.mjs"
  }
}
```

```ts
// CommonJS
const {} = require("package");
const {} = require("package/subpath");

// ES Modules
import {} from "package";
import {} from "package/subpath";
```

※ webpackなどのバンドラで独自に "module" フィールドをサポートしていた時代もある。

## moduleResolution

```ts
moduleResolution: "Classic" | "Node" | "Node10" | "Node16" | "NodeNext" | "Bundler"
```

- `Classic`
  - Classic TS 1.5 以前のモジュール解決。
- `Node` `Node10`
  - Node 12 以前のモジュール解決。type フィールドにかかわらず CommonJS が使用され main フィールドがエントリポイントになる。
- `Node16` `NodeNext`
  - type フィールドによって CommonJS / ES Modules が使用され exports フィールドがエントリポイントになる。
  - .js を読み込む場合は拡張子まで記述する必要がある。
- `Bundler`
  - type フィールドにかかわらず exports フィールドは require でなく import が使用される。なければ main がフォールバックになる。
  - .js を読み込む場合に拡張子を省略しても補完される。
