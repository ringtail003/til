https://www.amazon.co.jp/dp/B073GSDBGT/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1

# 呼んだきっかけ

書店で見つけて興味を持った。

# 読書に費やした日数

3日。

# 学んだこと

同僚のコードを真似てデータを持つオブジェクトにメソッドを生やす書き方をしていたのを何となく「変更に強い」と思っていたのだけど、DDDで言う値オブジェクトっぽい分類をしていたのだと気づいた。他にも「これが良い、変更に強い」とぼんやり思っていたものが、なぜ良いのか言語化できて、すっきりした感覚を得られた。反面、アンチパターンを実践していたものも少なくない。私の書く「値オブジェクトっぽいもの」は完全な値オブジェクトでなくルールに違反している。また契約による設計でなく防御的プログラミングを好んでいた。

同僚とのディスカッションで「なぜ良いのか」「なぜダメなのか」の論点がズレてしまう事があり疑問に思っていたが、オブジェクト指向・ドメイン駆動というパラダイムの共通の理解があれば、それに照らし合わせた論点のズレないディスカッションができるかもしれない。少なくとも、自分の経験則に基づいただけの良し悪しの判定よりかはずっと優れた判断基準を得られたと思う。

著者の増田さんが書籍に書いている通り、オブジェクト指向とDDDの全てを理想通りに実践するのは難しい。フロントエンドの世界ではビューを便利にレンダリングする機能がフレームワークに存在し、それらを無視してドメインオブジェクトにレンダリング結果に相当する文字列を持たせるのは冗長とも思える。またランタイムでどのような値が混入するか分からない側面が強く、アンチパターンの防御的プログラミングも実践せざるを得ない。ただ、根底にある考え方を理解した上で部分的に実践するものと意図的に切り捨てるものを取捨選択する事は、設計についての判断力を培う大きな学びになると思った。

フロントエンドの世界で一番の正義はフレームワークだと思っている。なぜなら、逆らうと意図した挙動が実現できず、開発の便利さの恩恵を受けることができないから。ただしフレームワークの関与しない「業務ロジックをどう書くべきか」についてドメインモデルやレイヤー化アーキテクチャは大いに参考になった。

以下、重要だと思った事のメモ。

## p86.ドメインオブジェクト

業務アプリケーションの中核は、業務データを使った判断・加工・計算の業務ロジック。オブジェクト指向で業務アプリケーションを開発する目的は、業務ロジックがどこに書いてあるか見つけやすくし修正を楽で安全にすること。そのために、業務データとその業務データを使って判断・加工・計算するロジックを同じクラスに置くことを徹底する。

関連する業務データと業務ロジックを１つにまとめたこのようなオブジェクトを **ドメインオブジェクト** と呼ぶ。

業務活動という問題領域（ドメイン）で扱うデータと業務ロジックをオブジェクトとして表現したものがドメインオブジェクト。

> https://www.slideshare.net/masuda220/ss-59756718 より抜粋

- 業務の関心事を抽象データ型として表現する
  - 顧客クラス
  - 商品クラス
  - 注文クラス
- 業務の知りたいこと・やりたいことをクラス名とメソッド名で表現する
- 実装の詳細は意識しない・させない（= getter/setterは使わない）

> https://www.slideshare.net/masuda220/ss-59756718 より抜粋

ドメインとは「ソフトウェアを利用する人たちの活動と関心事」。
反対に「ソフトウェアを作る活動」「コンピュータの仕組みや挙動」「画面仕様書・機能一覧・ユーザーストーリー」はドメインではない。

> https://www.slideshare.net/masuda220/ss-59756718 より抜粋

モデルとは「膨大な知識を要約したシンプルで分かりやすい説明」。
モデリングのスキルは「要約力」である。

> https://www.slideshare.net/masuda220/ss-59756718 より抜粋

ソフトウェアを利用する人たちの活動と関心事の本質を完結に表したもの。表現として下記のようなものがある。

- 会話
- ラフスケッチ
- コード
- 文章・図

> https://www.slideshare.net/masuda220/ss-59756718 より抜粋

レイヤー化アーキテクチャ

```
プレゼンテーション層 ┐
アプリケーション層   ├─ ドメイン層
データソース層      ┘

// 業務ルールの複雑さをドメイン層に集約して整理する
```

> https://www.slideshare.net/masuda220/ss-59756718 より抜粋

参照オブジェクト（Entity）

- 関心事への参照点
- 顧客との会話の語彙の起点
- 集約のルートとなる事が仕事

```
勤務条件
 - 給与（値オブジェクト）
 - 休暇（値オブジェクト）
 - 勤務時間（値オブジェクト）
```

値オブジェクト（ValueObject）

- 完全コンストラクタ：生成された時点で全ての状態を持つ
- 普遍：setterを書かず、新しい値が必要な時は別のオブジェクトを生成して返す
- ロジックの置き場所：判断・加工・計算を持つ
- 何もしないで素のデータを返すgetterはNG

```
期限切れの前日を計算
expireDate.add(-1)
↓
expireDate.previousDay();
↓
expireDate.dayOfFinalAlert();

// How より What
```

## p89.ドメインモデル

業務アプリケーションの対象領域（ドメイン）をオブジェクトのモデルとして整理したものを **ドメインモデル** と呼ぶ。ドメインモデルとは、業務で扱うデータと関連する業務ロジックを集めて整理したもの。ドメインモデルを見れば、業務全体がどういう関心事から成り立っているかを理解できる。

## p112.ドメインオブジェクトの見つけ方

ヒト・モノ・コトに分類する

分類 | 例
--- | ---
ヒト | 個人、部署
モノ | 商品、サービス、場所
コト | 予約、注文、出荷

### コトに着目する

業務アプリケーションの主な関心事はコトを記録しコトの発生を通知すること。

## p124.ドメインオブジェクトの設計パターン

ドメインオブジェクト | 設計パターン
--- | ---
値オブジェクト | プリミティブのラップ
コレクションオブジェクト | 配列・コレクションのラップ<br>ファーストクラスコレクション
区分オブジェクト | 区分の定義とロジック
列挙型の集合操作 | 状態遷移ルールなど

関心事のパターン | ロジック
--- | ---
口座パターン<br>Account | 対象を「口座」として用意し予定・実績・残高を記録算出する
期日パターン<br>DueDate | 期限と判断
方針パターン<br>Policy | ルールの複合による複雑な業務ロジックを表現する
状態パターン<br>State | 状態と、遷移できる・できないを表現する

## p150.三層＋ドメインモデル

層 | 役割
--- | ---
画面 | プレゼンテーション層
進行役 | アプリケーション層
記録と通知 | データソース層

## p161.ドメインモデルを育てる > プレゼンテーション層に影響される複雑さ

サービスは更新・参照を意識して区別するべき。
下記は１つのサービス内で更新と参照を同時に行うアンチパターン。

```
class BankAccountService {
  Amount withdraw(Amount amount) {
    repository.withdraw(amount);
    return repository.balance();
  }
}
```

## p165.利用者との約束事

預金を引き出す処理をベースに考える。

まず残高を確認し残高不足にならない事を確認した上で引き出し処理を呼び出す。このような約束ごとにする事によりサービスを提供する条件が明確になり設計がシンプルになる。これを **契約による設計** と呼ぶ。

```
if (bankAccouontService.canWithdraw(amount)) {
  bankAccouontService.withdraw(amount);
}
```

反対に、利用者が何をしてくるか分からないという前提で防御的ロジックを書くことを **防御的プログラミング** と呼ぶ。

```
class BankAccountServide {
  withdraw(Amount amount) {
    if (amount < 0) ...
    if (!canWithdraw()) ...
  }
}
```

防御的プログラミングは無意味にコードを複雑にし読みにくくする。どれだけ防御しても想定外の使われ方が起き、想定外の戻り値が起きてしまうのが現実。
約束を守った上でさらに異常が起きた場合は例外で通知する。

## テーブル設計

p179.
nullは「未知」であり、既知の事実を記録するデーターベースに持ち込むのは掟破りである。カラムにnullを含まないのがデータベース設計の基本。

p182.
主キーと外部キーを必ず設定する。事実として記録された複数のテーブルの関係を明確にし、コトの記録を完全なものにする。

p183.
コトの記録を変更しない。UPDATE文は使うべきではない。過去の記録を計算して必要な値を取り出す事が面倒な場合は、計算結果の記録テーブルを用意する。このテーブルのデータは元のコトの記録からいつでも再作成が可能である。

p194.
ドメインオブジェクトとテーブルを機械的にマッピングしてはいけない。ドメインオブジェクトは業務の関心事、かつテーブルは事実の記録であり、両者の設計は一致しない。

## p214.ビューとモデルの分離

モデルの設計に、ビューへの影響が出ることを気にしすぎているケースを時々みかける。例えば検索結果が０件の場合に「X件見つかりました」「見つかりませんでした」などの結果を表現する文字列をドメインオブジェクトに実装する事は自然である。

## WebAPIの設計

p237.
PUT/DELETEはアプリケーションの識別体系を事前に知っていることが前提となったリクエスト。`PUT /books/1234` は識別番号が `1234` でありUPDATE文を実行する事を具体的に依頼している。PUTには応答内容の規定がなく、成功した場合に複数のステータスコードを選択できため応答内容をどうするかの決め事が必要になる。決め事が多くなるほどアプリケーションは密結合になりAPIの修正や拡張が難しくなる。これを解決するために更新・削除はPOSTを使うようにする。実際に上書き更新するのか新しい履歴を追加するのかは、WebAPIを提供するアプリケーション側の責任になる。

```
POST /books/1234/updates
POST /books/1234/deletes
```

p252.
POSTでは新たに作られたリソースの識別番号のみを返す。そしてその内容を確認するために参照用の別のAPIを用意する。このように登録と参照を分けるのはアプリケーション設計の一般原則である。また対象とするリソースの参照は必要な最小の単位に分けることを重視して設計する。

```
GET members/1234/name
GET members/1234/gender
GET members/1234/dateOfBirth
```

## https://www.slideshare.net/masuda220/ss-59756718 からの抜粋

### エクストリーム・プログラミング

分析・設計・実装を **同じ人が一貫して毎日やる** 。
気づきやそれによる変更が日々あるものとし、ソフトウェアを業務に合わせて成長させる。
ソースコードが第一級のドキュメントとなり、プレスリリース・ユーザーズガイドはソースコードに書ききれない仕様を補助する。

反対の概念として挙がるのはウォーターフォール型の開発。
フェーズを切り、要件定義・外部設計・内部設計を固めてから次のフェーズに移る。

### ドメイン駆動設計

オブジェクト指向（OO）＋エクストリームプログラミング（XP）

- ドメインの知識を継続的に学習する
- 言葉を使ってモデリングする
- モデルとコードを一致させる
