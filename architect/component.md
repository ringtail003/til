# 愚痴るフェーズ

いつもいつもグチャグチャになっていくコンポーネント群をどうにかしたい。

## 例（擬似コード）

バインドしすぎ。何がどのタイミングで変更されるんだ？？分からねぇ！！！

```
<a-component
  sources="sources"
  config="config"
  choices="userList"
  chosen="user"
  on-user-selected="userSelected()"
  is-show-summary="!isTrialUser"
  is-admin="isAdmin"
><a-component>
```

とにかくでかい。

```
<div class="navbar">
  ...
  ...（何十行も続く）
  ...
</div>
<div class="container">
  <div class="column-left">
    <a-component></a-component>
    <b-component></b-component>
    ...
    ...（何十行も続く）
    ...
  </div>
  <div class="column-right">...</div>
  <button></button>
  <button></button>
</div>
```

やる事多い。

```
const componentController = () => {
  ...
  this.onSaveButtonClicked = () => {
    this.list = []; // 初期化して
    this.pending = true; // 画面の状態変更して
    this.repository.save.then( // サービス呼び出して
      () => { ... },
      () => { ... }, // エラーハンドリングして
    );
    this.disabledUserInput = false; // なんかいろいろ
  }
}
```

親子間の双方向の依存。

```
<parent>
  <child $parent="$parent"></child>
</parent>

// 子コントローラから親の振る舞いを呼び出す
this.$parent.save(this.data);
```

依存多すぎ。うんざり。

```
const componentController = (
  fooService,
  barService,
  fooTransFormer,
  fooFactory,
  appConfig,
  appConstants,
  ...
) => {}
```

## なんでこうなったのか（言い訳）

「MVC」というルールしかなかった。モデルがAPIレスポンスの形を表現しているだけで、その他の役割が全部ビューとコントローラに詰め込められた。ビューの状態も管理しなきゃいけないし、モデルに対する変更や、子コンポーネントに渡すデータの整形、DOM のイベント発火をトリガとして、とにかくいろんな事をひとつのメソッドに詰め込む習慣があった。

正直どうしていいのか分からなかった。フレームワークに双方向バインディングって仕組みがあるし、親子間コンポーネントを密結合させて子から親を参照するやり方も公式ドキュメントに乗っている。コントローラがちょっとデカくなってきたらロジックをサービスに追い出してサービスを注入するのがベストプラクティスだと思っていた。UIの中でひとつの機能をコンポーネントという括りでまとめて、その中で整合性が取れていれば何でも良かった。

コンポーネントの関心をひとつにする事はできない。ビューを持っている以上 DOM への関心は切り離せないし、双方向バインディングでオブジェクトを受け取った以上モデルを変更しないのは変。

本当どうにかしたい。
どうにかしたい。
どうにかしたい。
切実。

# グダグダ考えるフェーズ

## 世の中はどうしてる？（自分調べ、根拠はない）

### ステート管理（Flux, Redux, NgRx）

ステート管理だけで全て解決するとは思わない。

アプリケーションの複数箇所で使う汎用コンポーネントを考えてみる。
確認メッセージ付きの保存ボタンの汎用コンポーネントを作るとする。ボタンがクリックされた時、どのステートに対してのアクションにするのか？リストアイテムの複数選択をする汎用コンポーネントを作るとする。どのステートからリストを取得するのか？他のコンポーネントのステートによって自分自身のステートを変えたい時、特定のステートに依存してもなお汎用コンポーネントとして使えるのか？

どの単位でスコープを作ってステート管理するのか。ページ？モデル？

ステート管理をコンポーネントから追い出すだけで解決しそうにない。
いつものコンポーネントの作り方は、複数の責務を担っていないか？コンポーネントの持つ依存に明確なルールはあるのか？コンポーネントのロジックが複雑に分岐していないか？そこを解決しないと、ステート管理があちこち飛び交うだけになりそう。

結論、時期尚早だと思う。

### クリーンアーキテクチャ

ちょっとよく分からなかった。アプリケーション・ユースケースってフロントエンドのどの部分か、エンティティって具体的に何を示すのか分からない。クリーンアーキテクチャを体現できるフロントエンドのアプリケーションの構造が思いつかなくて、そんな理解度では却って混乱しそうな気がする。

### プレゼンテーション/コンテナコンポーネント

http://better-than-i-was-yesterday.com/presentational-and-container-components/
コンポーネントの目的を、プレゼンテーション（データの表示）とコンテナ（振る舞い）に分けましょうっていう考え方。
React発祥。提唱した Dan さんは「React hooksが使えるようになったからこの考え方はもう推奨じゃないよ」って言ってる。

### Atomic Design

https://www.slideshare.net/techblogyahoo/yahooatomicdesign
UIのパーツの粒度を明確に決めるガイドライン。再利用性を高めたり、コンポーネントカタログを作りやすくしたり、CSSのスコープを明確にしたり、それらの相乗効果で作業のコンフリクトを避ける事ができる。ただ実践で使うにはなかなか難しいらしい。Atomic Design にうまく当てはまらないものがあったり、無理にあてはめようとして冗長な構造を生みだしたりという問題があるらしい。

- Atoms（原子） これ以上分割できない最小単位
- Molecules（分子）原子 + 原子
- Organisms（有機体）分子 + 分子
- Templates ページの枠組み
- Pages（画面全体）

# 具体的にアイデアを考えるフェーズ

Atomic Design が直感的で分かりやすいと思うので、この粒度でコンポーネント分割しつつ役割を決める。そこにプレゼンテーション/コンテナコンポーネントの考え方を取り入れたい。

## コンポーネントの粒度

### (Atoms)

この粒度の該当コンポーネント：なし
`<input>` とか `<p>` とか、わざわざコンポーネントにする必要はなさそうだから。

### Unit Component (molecule)

モデルを受け取ってビューに表示する。

### Container Component (Organisms)

Unit/Container Component を複数配置して、それらのイベントやステートを橋渡しする。

### Widget Component (Organisms)

Container Component をひとつ以上配置して、モデルに変更を加える。

### (Template)

この粒度の該当コンポーネント：なし
コンポーネントでテンプレートのビューを作って include みたいな事させるのは複雑になるだけだから。

### Page Component (Pages)

Widget Component をひとつ以上配置して、スタイルを定義する。

## 役割

### Unit

- HTMLに興味を持つ
  - モデルを表示
  - UIの状態を変更
  - スタイル定義
  - DOMイベントの伝播
  - バリデーションの変更

### Container

- 子コンポーネントの関係に興味を持つ
  - コンポーネントを配置
  - 子コンポーネントにモデルを渡す
  - イベントの伝播
  - バリデーション用のステートを子コンポーネントに渡す

### Widget

- モデルに興味を持つ
  - データ取得
  - データ更新

### Page

- コンポーネントの配置に興味を持つ
  - スタイル定義

## 制約

### Unit

- アプリケーションのどこにでも配置できるような汎用的な名前を付ける
- モデルに変更を加えない
- イベント発火のプレフィクスを `on` とする

### Container

- スタイル定義を持たない
- モデルに変更を加えない
- イベントハンドリングのプレフィクスを `handle` とする
- HTMLElementを直接配置しない

### Widget

- スタイル定義を持たない
- HTMLElementを直接配置しない

### Page

- モデルを持たない
- ロジックを持たない
- HTMLElementを直接配置しない

## コンポーネントの配置

```
src
 |- app
    |- shared
    |   |- components
    |   |   |- units
    |   |   |  |- A1
    |   |   |  |- A2
    |   |   |- containers
    |   |   |  |- B1
    |   |   |  |- B2
    |   |   |- widgets
    |   |   |  |- C1
    |   |   |  |- C2
    |   |  module.ts
    |      
    |- pages
    |   |- {name}
    |   |   |- components
    |   |   |   |- units
    |   |   |   |  |- AA1
    |   |   |   |  |- module.ts
    |   |   |   |- containers
    |   |   |   |  |- BB1
    |   |   |   |  |- module.ts
    |   |   |   |- widgets
    |   |   |   |  |- CC1
    |   |   |   |  |- module.ts
    |   module.ts
    |   index.ts
    |   index.html
    |   index.scss
```

# これで何が解決できるのか考えるフェーズ

## 依存は一方向になる

親 -> 子に依存する。子は「どこに配置されるのか」は知らない。

## テスト簡単そう

プレゼンテーションコンポーネントはロジックを持たないので、簡単なテストのみにする。

## デザイナーとの分業？

プレゼンテーションコンポーネントを StoryBook に集めたら分業できそう。
現段階ではやりすぎ感があるので、夢。

# まとめ

全部解決できるとは思わない。ケースに当てはまらないコンポーネントも出てくるだろうし、この構造が失敗しないとは限らない。ベストな設計を見つけるための試行錯誤としてやってみたい。
