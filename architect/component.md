# Overview

component の設計についてのヒント

# Links

- [\[DDD\]ドメイン駆動 \+ オニオンアーキテクチャ概略 \- Qiita](https://qiita.com/little_hand_s/items/2040fba15d90b93fc124)
- [モデルでドメイン知識を表現するとは何か\[DDD\] \- little hands' lab](https://little-hands.hatenablog.com/entry/2017/10/04/201201)
- [フロントエンドにおいてModel\-View\-Controllerは死んだのか？ \| POSTD](https://postd.cc/is-mvc-dead-for-the-frontend/)

# Problem

- コントローラが Fat になりがち
- モデルがただの器になりがち
- ビジネスロジックをどこに置くのか

# Misc

## コントローラはそもそも単一責任の原則を破綻させている

[Webアプリケーション開発者から見た、MVCとMVP、そしてMVVMの違い \- Qiita](https://qiita.com/shinkuFencer/items/f2651073fb71416b6cd7)

コンポーネントのステータス、UIのステータス、イベントハンドリング（DOM・JavaScriptの非同期処理）など様々な責務を追っている。

## MVC とは

- モデル：ビジネスロジックを表現する要素
- ビュー：モデルのデータを取り出してユーザーが見るのに適した形で表示する要素
- コントローラ：ユーザー入力をモデルに伝える要素

データの変更をビューに通知するのはモデルの責任である。
コントローラは直接に描画を行ったりモデルの内部データを直接操作したりしない。

> **MVC の構造** より引用
> https://ja.wikipedia.org/wiki/Model_View_Controller

## モデルがビジネスロジックを持つ事のメリット

ありがちなパターン：
ユーザー入力によるメッセージの保存を受け付ける。最大数 100 を超えていなければ保存処理を実行する。検証ロジックと保存処理後のモデルの変更はコントローラが担う。

この場合、モデルは DB 構造を投影しただけの Entity オブジェクトとなる。このモデルを別のコンポーネントでも利用する場合、最大数に関するビジネスロジックを共有する事ができない。

モデルがビジネスロジックを持つ場合、モデルは値の他に振る舞いを持つ事になる。このモデルが他のコンポーネントで利用された場合でもビジネスロジックを共有する事ができる。

## 何をどこに持つべきか

### コンポーネントのステータス

例）チャットアプリのスレッドのメッセージの配列を保持する変数

Flux などステート管理に特化した仕組みを取り入れる事でコントローラは開放される。

### UIのステータス

例）新規メッセージが入力されていない場合に保存ボタンを押せないようにする処理

View に閉じ込める事ができないか？

AngularJS であればビュー専用の変数 `ng-model="$checked"` や、Angular であれば DOM を参照する `<input #foo>` などが利用できる。

これらだけでステータス管理できない場面は多々あるが、モデルが DB 構造および API レスポンスの構造を体現しただけの器になっているのではないか？ビューがデータ表示とステータス管理に詰まらないように ViewModel を取り入れるのも解決策のひとつかもしれない。

[Angular\.jsで組む場合のアーキテクチャは、MVCじゃなくてMVVMの方が良いっぽいと思った話](https://blog.anatoo.jp/entry/20140110/1389296912)

### イベントハンドリング（DOM）

例）保存をクリックした時のロジック

これはコントローラの本来の責務。
ただし API リクエストを呼び出すのはモデルで、コントローラはイベントを監視しモデルに通知するのみ。

### イベントハンドリング（JavaScriptの非同期処理）

例）保存が成功した時に「保存されました」メッセージを表示する

モデルが行う API リクエストの結果をコールバックまたは Observable パターンで受け取る？？
Wikipedia にあったコントローラの「ユーザー入力をモデルに伝える要素」と外れてしまうが、モデルとビューの橋渡しと考えるとこのやり方は悪くないかも。
